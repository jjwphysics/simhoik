<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HOIK 문학 · 3D 행성계</title>
  <meta name="theme-color" content="#0f172a" />

  <!-- Tailwind (for base typography only; safe to remove if not needed) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config={theme:{extend:{fontFamily:{sans:["Pretendard Variable","Inter","system-ui","Noto Sans KR","Apple SD Gothic Neo","sans-serif"]}}}};</script>
  <link rel="preconnect" href="https://cdn.jsdelivr.net"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable-dynamic-subset.css"/>

  <style>
    html,body{height:100%;}
    body{margin:0;background:radial-gradient(1200px 800px at 50% -20%, rgba(56,189,248,.10), transparent 60%), linear-gradient(135deg,#0b1020,#0e1329 55%,#0a0f22);color:#e5eef7;overflow-x:hidden;overflow-y:auto}
    .scene-wrap{position:relative;width:min(1200px,95vw);height:min(76vh,820px);margin:2.5rem auto 0;z-index:1}
    #bg-text{position:fixed;inset:0;z-index:0;pointer-events:none;user-select:none;color:#fff;opacity:.32;filter:blur(2px) saturate(1.05) contrast(1.05);padding:5vmin;line-height:1.6;white-space:pre-wrap;overflow:hidden;font-size:clamp(16px,3.0vmin,42px)}
    .label{font-family:"Pretendard Variable",system-ui,sans-serif;font-size:12px;white-space:nowrap;color:#d9f2ff;text-shadow:0 1px 0 rgba(0,0,0,.6);padding:2px 6px;border-radius:999px;background:rgba(2,6,23,.35);border:1px solid rgba(148,163,184,.25);backdrop-filter:blur(4px);pointer-events:none}
    .tip{position:fixed;z-index:50;max-width:min(60ch,80vw);background:rgba(2,6,23,.9);backdrop-filter:blur(8px);border:1px solid rgba(148,163,184,.25);border-radius:12px;padding:10px 12px;color:#e9f2fb;font-size:14px;line-height:1.55;box-shadow:0 10px 30px rgba(0,0,0,.35);display:none}
  </style>
</head>
<body class="min-h-screen font-sans">
  <!-- 상단 메뉴 -->
  <header class="relative z-10 w-full border-b border-white/10 backdrop-blur">
    <nav class="max-w-5xl mx-auto grid grid-cols-2 divide-x divide-white/10">
      <a href="/" class="text-center py-3 text-lg tracking-tight hover:bg-white/5">메인</a>
      <a href="/hoik.html" class="text-center py-3 text-lg tracking-tight hover:bg-white/5 underline underline-offset-4">호익문학</a>
    </nav>
  </header>
  <!-- 배경에 흐릿한 전문 텍스트 -->
  <div id="bg-text" aria-hidden="true"></div>

  <!-- 3D 씬 컨테이너 -->
  <div id="scene" class="scene-wrap"></div>

  <!-- 장르별 개수 표시 -->
  <section class="relative z-10 max-w-5xl mx-auto px-4 mt-4 mb-12">
    <div id="legend" class="flex flex-wrap gap-2 opacity-90"></div>
  </section>

  <!-- 툴팁 -->
  <div id="tooltip" class="tip" role="status" aria-live="polite"></div>

  <!-- Import map for three.js -->
  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { CSS2DRenderer, CSS2DObject } from 'https://unpkg.com/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

    // ====== Helpers: Works & Background Text ======
    async function loadWorks(){
      try{
        const r = await fetch('/data/works.json',{cache:'no-store'});
        if(!r.ok) throw new Error('no external works');
        return await r.json();
      }catch{
        const inline = document.getElementById('works-inline');
        return inline ? JSON.parse(inline.textContent) : [];
      }
    }
    function fillBackgroundText(works){
      const el = document.getElementById('bg-text');
      if(!el) return;
      const w = works[(Math.random()*works.length)|0] || {};
      const text = (w.content || w.excerpt || 'HOIK 문학');
      const targetLen = 2200;
      const src = text.length >= targetLen ? text : (text + "\n\n").repeat(Math.ceil(targetLen / (text.length+2)));
      el.textContent = src;
      // Responsive fit
      let lo=14, hi=64, best=18;
      const within=()=> (el.scrollHeight <= innerHeight*1.05) && (el.scrollWidth <= innerWidth*1.02);
      for(let i=0;i<9;i++){
        const mid=(lo+hi>>1); el.style.fontSize=mid+'px';
        if(within()){ best=mid; lo=mid+1; } else { hi=mid-1; }
      }
      el.style.fontSize=best+'px';
    }

    // ====== Scene Setup ======
    const container = document.getElementById('scene');
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1020, 300, 900);

    const initialW = container.clientWidth || 800;
    const initialH = container.clientHeight || 600;
    const camera = new THREE.PerspectiveCamera(55, initialW/initialH, 0.1, 2000);
    camera.position.set(0, 140, 420);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(initialW, initialH);
    renderer.setClearAlpha(0);
    container.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(initialW, initialH);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.inset = 0;
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);

    // Lighting
    const point = new THREE.PointLight(0x7dd3fc, 1.2, 0, 2); point.position.set(160,180,140); scene.add(point);
    scene.add(new THREE.AmbientLight(0xbcd4e6, 0.55));

    // ===== Center HOIK Sphere (big & fast spin) =====
    function createHoikMaterial(){
      const cv = document.createElement('canvas'); cv.width=2048; cv.height=1024; const ctx=cv.getContext('2d');
      const g = ctx.createLinearGradient(0,0,0,1024); g.addColorStop(0,'#0a2540'); g.addColorStop(1,'#0b1730');
      ctx.fillStyle=g; ctx.fillRect(0,0,cv.width,cv.height);
      ctx.font='bold 420px Pretendard, Inter, system-ui, sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.shadowColor='rgba(56,189,248,0.85)'; ctx.shadowBlur=80; ctx.fillStyle='#9be8ff'; ctx.fillText('HOIK', cv.width/2, cv.height/2);
      const tex = new THREE.CanvasTexture(cv); tex.anisotropy=8; tex.wrapS=THREE.RepeatWrapping; tex.wrapT=THREE.ClampToEdgeWrapping;
      return new THREE.MeshStandardMaterial({ color:0x246b8f, metalness:0.25, roughness:0.35, map:tex, emissive:0x1aa0d0, emissiveMap:tex, emissiveIntensity:0.8 });
    }
    const sun = new THREE.Mesh(new THREE.SphereGeometry(60,64,64), createHoikMaterial());
    scene.add(sun);
    const sunSpin = 2.5;

    // ===== Orbits & Planets =====
    const radii = [120, 180, 240, 300];
    const speeds = [0.30, 0.24, 0.20, 0.16];
    const tilts  = [ [22, 12], [-14, 8], [8, -10], [-5, -2] ];
    const genreColors = [0x6fd3ff, 0xffb869, 0x64e3b0, 0xb792ff];

    // 컨트롤러(특수 궤도)
    const planetControllers = [];

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function updateMouse(e){ const r=container.getBoundingClientRect(); mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1; }

    let paused=false, hover=null;
    const tip = document.getElementById('tooltip');
    function showTip(x,y,work){ tip.style.left=Math.min(x+18, innerWidth-320)+'px'; tip.style.top=Math.min(y+18, innerHeight-20)+'px'; tip.innerHTML=`<div style="font-weight:800;color:#c8ecff">${work.title||''}</div><div style="font-size:12px;color:#9fb5c6;margin-top:2px">${work.genre||''} · ${work.date||''}</div><div class="mt-1">${work.excerpt||''}</div>`; tip.style.display='block'; }
    function hideTip(){ tip.style.display='none'; }

    window.addEventListener('pointermove', (e)=>{ updateMouse(e); if(!hover) hideTip(); else showTip(e.clientX, e.clientY, hover.userData.work); });
    window.addEventListener('click', ()=>{ if(!hover) return; const w=hover.userData.work; if(w?.slug) location.href=`/works/${w.slug}.html`; });
    // 모바일 터치 탭 지원
    window.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; if(!t) return; updateMouse(t); raycaster.setFromCamera(mouse, camera); const ih=raycaster.intersectObjects(hitTargets,false)[0]?.object; if(ih){ const w=ih.userData.work; if(w?.slug) location.href=`/works/${w.slug}.html`; } }, {passive:true});

    // Resize
    function onResize(){
      const rw = container.clientWidth || 800; const rh = container.clientHeight || 600;
      renderer.setSize(rw, rh); labelRenderer.setSize(rw, rh); camera.aspect = rw/rh; camera.updateProjectionMatrix();
    }
    new ResizeObserver(onResize).observe(container);
    window.addEventListener('resize', ()=>{ onResize(); if(window.__worksCache) fillBackgroundText(window.__worksCache); });

    // Camera orbit controls (simple inertial)
    let isDrag=false, lastX=0, lastY=0, yaw=0, pitch=-0.06, inertiaX=0, inertiaY=0;
    container.addEventListener('pointerdown', e=>{ isDrag=true; lastX=e.clientX; lastY=e.clientY; updateMouse(e); });
    window.addEventListener('pointerup', ()=>{ isDrag=false; });
    window.addEventListener('pointermove', e=>{ if(isDrag){ const dx=(e.clientX-lastX)/200, dy=(e.clientY-lastY)/200; yaw+=dx; pitch+=dy; pitch=Math.max(-0.9,Math.min(0.6,pitch)); lastX=e.clientX; lastY=e.clientY; inertiaX=dx; inertiaY=dy; } });

    // ===== Build System from Works =====
    const works = await loadWorks(); window.__worksCache = works; fillBackgroundText(works);

    const GENRE_ORDER = ["시","단편","에세이","연작"];
    const buckets = [[],[],[],[]];
    for(const w of works){ const gi=GENRE_ORDER.indexOf(w.genre||''); buckets[(gi===-1?3:gi)].push(w); }

    const planetMeshes = []; // for tests & scaling
    const hitTargets = []; // larger invisible colliders for easy clicking
    const orbitGroups = [];

    function makeOrbitLine(radius, color){
      const seg=256; const g=new THREE.BufferGeometry(); const pos=new Float32Array((seg+1)*3);
      for(let i=0;i<=seg;i++){ const t=i/seg*Math.PI*2; pos[i*3]=Math.cos(t)*radius; pos[i*3+1]=0; pos[i*3+2]=Math.sin(t)*radius; }
      g.setAttribute('position', new THREE.BufferAttribute(pos,3));
      return new THREE.LineLoop(g, new THREE.LineBasicMaterial({color, transparent:true, opacity:.35}));
    }

    for(let i=0;i<4;i++){
      const grp = new THREE.Group();
      grp.rotation.x = THREE.MathUtils.degToRad(tilts[i][0]);
      grp.rotation.z = THREE.MathUtils.degToRad(tilts[i][1]);
      scene.add(grp); orbitGroups.push(grp);

      grp.add(makeOrbitLine(radii[i], genreColors[i]));

      const items = buckets[i];
      const n = Math.max(1, items.length);
      const angleStart = Math.random()*Math.PI*2;
      for(let k=0;k<n;k++){
        const data = items[k] || { title:`(empty ${i+1}-${k+1})`, slug:'#', genre: GENRE_ORDER[i] };
        const pivot = new THREE.Object3D(); pivot.rotation.y = angleStart + k*(Math.PI*2/n); grp.add(pivot);
        // 자동 회전 여부 플래그(가장 안쪽 궤도는 수동 제어)
        pivot.userData.auto = (i !== 0);

        const planet = new THREE.Mesh(new THREE.SphereGeometry(7.5,24,24), new THREE.MeshStandardMaterial({ color: genreColors[i], metalness:.2, roughness:.35 }));
        planet.position.set(radii[i],0,0); planet.userData={ work:data, orbitIndex:i }; pivot.add(planet);

        // 클릭 히트박스(투명 큰 구)
        const collider = new THREE.Mesh(
          new THREE.SphereGeometry(12, 16, 16),
          new THREE.MeshBasicMaterial({ transparent:true, opacity:0.001, depthWrite:false })
        );
        collider.position.copy(planet.position);
        collider.userData = { work: data, orbitIndex: i, planet };
        pivot.add(collider);
        hitTargets.push(collider);

        // 가장 안쪽 궤도: 카메라 전방 섹터 내 왕복 공전으로 클릭성 향상
        if(i===0){
          const sectorMin = -Math.PI*0.65;  // -117°
          const sectorMax =  Math.PI*0.65;  // +117°
          const base = THREE.MathUtils.clamp(pivot.rotation.y, sectorMin, sectorMax);
          planetControllers.push({ pivot, angle: base, dir: 1, v: speeds[0], min: sectorMin, max: sectorMax });
        }

        const labelEl = document.createElement('div'); labelEl.className='label'; labelEl.textContent = data.title; const label = new CSS2DObject(labelEl); label.position.set(12,12,0); planet.add(label);

        planetMeshes.push(planet);
      }
    }

    // ===== Loop =====
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Camera orbit around center
      yaw += inertiaX*0.96; inertiaX*=0.94; inertiaY*=0.94;
      const r=420; const cx=Math.sin(yaw)*r, cz=Math.cos(yaw)*r, cy=150+Math.sin(pitch)*70; camera.position.set(cx,cy,cz); camera.lookAt(0,0,0);

      // Sun spin
      sun.rotation.y += sunSpin * dt;

      // 특수 컨트롤(안쪽 궤도): 전방 섹터 내 왕복 + 나머지 연속 공전
      if(!paused){
        for(const c of planetControllers){
          c.angle += c.v * dt * c.dir;
          if(c.angle > c.max){ c.angle = c.max; c.dir = -1; }
          else if(c.angle < c.min){ c.angle = c.min; c.dir = 1; }
          c.pivot.rotation.y = c.angle;
        }
        for(let i=0;i<orbitGroups.length;i++){
          const group=orbitGroups[i]; const s=speeds[i]*dt;
          for(const ch of group.children){ if(ch.type==='Object3D' && ch.userData?.auto) ch.rotation.y += s; }
        }
      }

      // Hover detection
      raycaster.setFromCamera(mouse, camera);
      const ih = raycaster.intersectObjects(hitTargets, false)[0]?.object || null;
      if(ih !== hover){
        if(hover){ (hover.userData.planet||hover).scale.set(1,1,1); hideTip(); }
        hover = ih; paused = !!hover;
        if(hover){ (hover.userData.planet||hover).scale.set(1.28,1.28,1.28); }
      }

      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    animate();

    // ===== Tests (do not modify existing ones) =====
    console.assert(planetMeshes.length === works.length || works.length===0, 'T1: 행성 수 === 작품 수(또는 샘플)');
    console.assert(document.querySelector('#bg-text').textContent.length > 0, 'T2: 배경 텍스트 채움');
    console.assert(labelRenderer.domElement.style.pointerEvents==='none','T3: 라벨 클릭 방해 없음');
    // Additional tests
    console.assert(renderer.domElement instanceof HTMLCanvasElement, 'T4: WebGL 캔버스 존재');
    console.assert(camera.aspect > 0, 'T5: 카메라 aspect 정상');
      // ===== Legend 채우기 =====
    const legendEl = document.getElementById('legend');
    if(legendEl){
      const counts = buckets.map(b=>b.length);
      const names = ["시","단편","에세이","연작"];
      const toRGB=(hex)=>({r:(hex>>16)&255,g:(hex>>8)&255,b:hex&255});
      legendEl.innerHTML = names.map((n,i)=>{ const {r,g,b}=toRGB(genreColors[i]); return `<span class="px-2 py-1 rounded-full text-xs" style="background:rgba(${r},${g},${b},.22);border:1px solid rgba(${r},${g},${b},.45)">${n} · ${counts[i]}</span>`; }).join('');
    }
  </script>

  <!-- Inline sample data (used when /data/works.json is missing) -->
  <script id="works-inline" type="application/json">[
    { "slug": "bronze-odyssey", "title": "T1 Hoker", "genre": "단편", "date": "2024-12-12", "excerpt": "LP는 빠지고, 달은 떠오르고, 채팅창엔 바람만 분다.", "content": "호익은 할머니를 좋아한다. 에구구!" },
    { "slug": "night-queue", "title": "불꽃 카이팅", "genre": "에세이", "date": "2025-01-09", "excerpt": "3연패의 끝에서야 인간은 겸허를 배운다.", "content": "호익은 할머니를 좋아한다. 에구구!" },
    { "slug": "laning-haiku", "title": "할카스 심호익", "genre": "시", "date": "2025-02-01", "excerpt": "첫 웨이브여 / 정글은 오지 않는다 / 미니언만 온다", "content": "호익은 할머니를 좋아한다. 에구구!" },
    { "slug": "duo-memo", "title": "호익과 할머니", "genre": "연작", "date": "2025-03-17", "excerpt": "호익은 할머니를 좋아한다.", "content": "호익은 할머니를 좋아한다. 에구구!" }
  ]</script>
  <!-- 하단 푸터 -->
  <footer class="relative z-10 border-t border-white/10 py-10 mt-6">
    <div class="max-w-6xl mx-auto px-4 sm:px-6 text-sm flex flex-col sm:flex-row items-center gap-3 justify-between text-slate-300">
      <p>© <span id="year"></span> 심호익 (SimHoik) . All rights reserved.</p>
      <div class="opacity-70">HOIK</div>
    </div>
  </footer>

  <script>
    // 푸터 연도 채우기
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
</body>
</html>
